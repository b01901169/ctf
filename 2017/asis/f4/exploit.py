from pwn import *
from Crypto.PublicKey import RSA
from Crypto.Util import *
from base64 import b64decode
import time
import signal
import primefac
import gmpy
import gmpy2

def gen_pubkey(p):
    assert gmpy.is_prime(p) != 0
    B = bin(p).strip('0b')
    print len(B)
    k = random.randrange(len(B))
    k, l = min(k, len(B) - k), max(k, len(B) - k)
    assert k != l
    print 'k:', k, 'sign:', int(B[k])
    print 'l:', l, 'sign:', int(B[l])
    BB = B[:k] + str(int(B[k]) ^ 1) + B[k+1:l] + str(int(B[l]) ^ 1) + B[l+1:]
    q = gmpy.next_prime(int(BB, 2))
    print 'z:', q - int(BB,2)
    assert p != q
    n = p*q
    return n

class TimeoutError(Exception):
  pass

def handler(signum, frame):
  raise TimeoutError()

count = 0
verbose = False

for i in range(1):
  print 'count:', count
  count += 1
  r = remote('66.172.27.77', 54979)

  junk = r.recv(2048)
  junk = r.recv(2048)
  if verbose:
    print junk
  
  time.sleep(0.5)

  r.sendline('e')
  data = r.recv(2048)
  if verbose:
    print data
  enc = data.split()[2]

  r.sendline('p')
  
  data = r.recv(2048)
  if verbose:
    print data
  lines = data.split('\n')
  
  key64 = ''.join([x for x in lines[2:-2]])
  if verbose:
    print key64
  
  keyDER = b64decode(key64)
  
  keyPub = RSA.importKey(keyDER)
  if verbose:
    print 'n:', keyPub.n
    print 'e:', keyPub.e

  n = keyPub.n
  e = keyPub.e

  '''
  # testing
  n = gen_pubkey(number.getPrime(128))
  e = 65537

  '''
  
  
  print 'n:', n
  print 'n length:', len(bin(n)[2:])
  bits = (len(bin(n)[2:]) + 1) / 2
  print 'p length:', bits
  found = False
  start_time = time.time()
  for sign1 in range(-1,2,2):
    for sign2 in range(-1,2,2):
      for j in range(1,bits):
        k = j
        l = bits - k
        print (k, sign1, l, sign2)
        for z in range(0,1000,2):
          diff = sign1 * 2 ** (bits-k-1) + sign2 * 2 ** (bits-l-1) + z
          t2 = n + (diff/2) ** 2
          if gmpy.is_square(int(t2)):
            t = gmpy2.isqrt(int(t2))
            print 'n =', n
            print 'e =', e
            print 'enc =', enc
            print 'p =', int(t + diff/2)
            p = int(t + diff/2)
            print 'q =', int(t - diff/2)
            q = int(t - diff/2)
            print 'q % e =', (q % e)
            print 'p * q =', p*q
            #d = number.inverse(e, (p-1)*(q-1))
            dp = number.inverse(e, (p-1))
            print 'dp =', dp
            m = pow(int(enc), dp, p)
            print 'm =', m
            #print number.long_to_bytes(m)
            found = True
          if found:
            break
        if found:
          break
      if found:
        break
    if found:
      break

  running_time = start_time - time.time()
  print 'running time:', running_time
  r.close()


