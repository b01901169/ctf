import sympy
from pwn import *

def inv(x,m):
  return sympy.invert(x,m)

p1 = 26440615366395242196516853423447
p2 = 27038194053540661979045656526063
p3 = 32581479300404876772405716877547

f = open('flag.enc','rb')
cipher = f.read()
c = 0
for s in cipher:
  c *= 256
  c += ord(s)

n = p1*p2*p3
phin = (p1-1)*(p2-1)*(p3-1)
e = 3

def pow_mod(a, b, m):
  s = 1 % m
  count = 0
  while b != 0:
    #print count
    if (b%2) == 1:
      s = (s * a) % m
    a = (a * a) % m
    b = b//2
    count = count + 1
  return s

def iroot(k, n):
    hi = 1
    while pow(hi, k) < n:
        hi *= 2
    lo = hi / 2
    while hi - lo > 1:
        mid = (lo + hi) // 2
        midToK = pow(mid, k)
        if midToK < n:
            lo = mid
        elif n < midToK:
            hi = mid
        else:
            return mid
    if pow(hi, k) == n:
        return hi
    else:
        return lo

multiple = 0

t2 = 19616973567618515464515107624812
p2 = 27038194053540661979045656526063

mul = 1
target = 0x306374667b
target_small = 0x3000000000
target_large = 0x3064000000
while 1:
  k = mul * 256 + 255
  t = k * p2 + t2
  head = hex(t)[2:12]
  h_int = int(head,16)
  print head
  if (h_int > target) & (h_int < target_large):
    mul = mul - max(1,mul>>36)
    mul = mul * 256
    continue
  if pow_mod(t,e,n) == c:
    print t
    break
  mul += 1




#modular = 1154476955857930519577189240628115962144643200152026380474106032
#l = 519221939256621598011025536728798796951892704292007009236680036



#while 1:
#  print multiple
#  mm = multiple * modular + l
#  tmp = mm * n + c
#  test = iroot(e,tmp)
#  if pow(test,3) == tmp:
#    print test
#    break
#  multiple += 1
